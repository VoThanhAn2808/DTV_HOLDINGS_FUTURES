<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Dashboard Equity DTV HOLDINGS</title>
<style>
*{box-sizing:border-box}

/* ====== BODY ====== */
body{
    margin:0;
    font-family:'Segoe UI',Tahoma;
    background:#f4f6f5;
    color:#222;
}

/* ====== HEADER ====== */
header{
    background:#ffffff;
    padding:20px;
    text-align:center;
    border-bottom:4px solid #f2b705;
}

h1{
    margin:0;
    font-size:26px;
    font-weight:700;
    color:#222;
}

.subtitle{
    margin-top:6px;
    font-size:14px;
    color:#2e7d32;
    font-weight:600;
}

/* ====== BUTTON ====== */
.controls{
    margin-top:15px;
    display:flex;
    justify-content:center;
    gap:12px;
    flex-wrap:wrap;
}

.btn{
    padding:10px 18px;
    border:none;
    border-radius:6px;
    font-weight:600;
    cursor:pointer;
}

.btn-primary{background:#f2b705;color:#000}
.btn-secondary{background:#444;color:#fff}
.btn-warning{background:#ddd;color:#000}

/* ====== STATUS ====== */
.status{
    display:flex;
    align-items:center;
    gap:6px;
    background:#f7f7f7;
    padding:6px 12px;
    border-radius:20px;
    font-size:13px;
}

.status-dot{
    width:10px;height:10px;border-radius:50%;
}
.status-dot.success{background:#2e7d32}
.status-dot.loading{background:#f2b705}
.status-dot.error{background:#c62828}

/* ====== CONTAINER ====== */
.container{
    width:96%;
    max-width:1400px;
    margin:20px auto;
}

/* ====== INFO ====== */
.info-banner{
    background:#ffffff;
    border:1px solid #ddd;
    padding:15px;
    border-radius:8px;
    display:flex;
    justify-content:space-between;
    flex-wrap:wrap;
    gap:10px;
}

/* ====== SUMMARY ====== */
.summary{
    display:grid;
    grid-template-columns:repeat(auto-fit,minmax(220px,1fr));
    gap:15px;
    margin:20px 0;
}

.summary-card{
    background:#ffffff;
    border:1px solid #ddd;
    padding:18px;
    border-radius:10px;
}

.summary-card .label{
    font-size:13px;
    color:#555;
}

.summary-card .value{
    font-size:22px;
    font-weight:700;
}

.green{color:#2e7d32}
.red{color:#c62828}
.gold{color:#f2b705}
.blue{color:#1565c0}

/* ====== PERIOD SELECT ====== */
.period-filter{
    margin-bottom:15px;
    display:flex;
    align-items:center;
    gap:10px;
}

.period-filter label{
    font-weight:600;
    color:#444;
}

.period-filter select{
    padding:8px 12px;
    border:2px solid #f2b705;
    border-radius:6px;
    font-size:14px;
    font-weight:600;
    background:#fff;
    color:#222;
    cursor:pointer;
}

.period-filter select:focus{
    outline:none;
    border-color:#e6ac00;
}

/* ====== TABLE ====== */
table{
    width:100%;
    border-collapse:collapse;
    font-size:13px;
}

th{
    background:#e6ac00;
    color:#000;
    padding:10px;
    border:1px solid #d4a000;
}

td{
    padding:8px;
    border:1px solid #e0e0e0;
    text-align:center;
}

tr:nth-child(even){background:#fafafa}

.rank-1{background:#fff3cd}
.rank-2{background:#f1f1f1}
.rank-3{background:#fbe9e7}

.period-badge{
    background:#fff3cd;
    color:#8a6d00;
    padding:3px 7px;
    border-radius:4px;
    font-weight:600;
}

/* ====== LOADING ====== */
.loading-overlay{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,.4);
    display:none;
    justify-content:center;
    align-items:center;
    z-index:999;
}
.loading-overlay.show{display:flex}

.spinner{
    width:45px;height:45px;
    border:4px solid #eee;
    border-top:4px solid #f2b705;
    border-radius:50%;
    animation:spin 1s linear infinite;
}
@keyframes spin{to{transform:rotate(360deg)}}

/* ====== NOTIFICATION ====== */
.notification{
    position:fixed;
    top:20px;
    right:20px;
    padding:14px 18px;
    background:#2e7d32;
    color:#fff;
    border-radius:6px;
    display:none;
}
.notification.show{display:block}
.notification.error{background:#c62828}

/* ·∫®n b·∫£ng chi ti·∫øt */
#detailBox {
    display: none;
}


</style>
</head>

<body>

<div class="loading-overlay" id="loadingOverlay">
    <div class="spinner"></div>
</div>

<div class="notification" id="notification"></div>

<header>
    <h1>Dashboard Equity DTV HOLDINGS</h1>
    <div class="controls">
        <button class="btn btn-primary" onclick="forceRefresh()">üîÑ L√†m m·ªõi</button>
        <button class="btn btn-secondary" id="autoRefreshBtn" onclick="toggleAutoRefresh()">‚è∏Ô∏è T·∫°m d·ª´ng</button>
        <div class="status">
            <span class="status-dot success" id="statusDot"></span>
            <span id="statusText">Ch∆∞a k·∫øt n·ªëi</span>
        </div>
    </div>
</header>

<div class="container">

    <!-- SETUP BANNER -->
    <div class="setup-banner" id="setupBanner">
        <h3>üìù Nh·∫≠p Link CSV Google Sheets</h3>
        
        <label>üîó Link CSV:</label>
        <input type="text" id="csvUrlInput" placeholder="https://docs.google.com/spreadsheets/d/e/2PACX-.../pub?output=csv&gid=0">
        
        <button onclick="saveCsvUrl()">üíæ L∆ØU V√Ä T·∫¢I D·ªÆ LI·ªÜU</button>
    </div>

    <div class="info-banner">
        <div class="info-item">
            <strong>‚è∞ C·∫≠p nh·∫≠t:</strong> <span id="lastUpdate">Ch∆∞a t·∫£i</span>
        </div>
        <div class="info-item">
            <strong>üîÑ T·ª± ƒë·ªông:</strong> M·ªói <span id="intervalTime">5</span>ph√∫t
        </div>
        <div class="info-item">
            <strong>üìä S·ªë l·∫ßn t·∫£i:</strong> <span id="loadCount">0</span>
        </div>
        <div class="info-item">
            <strong>üîó Tr·∫°ng th√°i:</strong> <span id="connectionStatus" style="color: #666;">Ch∆∞a k·∫øt n·ªëi</span>
        </div>
    </div>

    <!-- T·ªîNG K·∫æT -->
    <div class="summary">
        <div class="summary-card">
            <div class="label">üí∞ T·ªïng Equity ƒê·∫ßu K·ª≥</div>
            <div class="value gold" id="sumEquityStart">0</div>
        </div>
        <div class="summary-card">
            <div class="label">üíµ T·ªïng Equity Hi·ªán T·∫°i</div>
            <div class="value blue" id="sumEquityNow">0</div>
        </div>
        <div class="summary-card">
            <div class="label">üìà T·ªïng PnL</div>
            <div class="value green" id="sumPnL">0</div>
        </div>
        <div class="summary-card">
            <div class="label">üìä % Trung B√¨nh</div>
            <div class="value" id="avgPercent">0%</div>
        </div>
    </div>

    <!-- B·∫¢NG CHI TI·∫æT -->
    <div class="table-box" id="detailBox">
        <h3>üìã B·∫£ng chi ti·∫øt theo k·ª≥</h3>
        <table id="detailTable">
            <thead>
                <tr>
                    <th>STT</th>
                    <th>Account</th>
                    <th>K·ª≥</th>
                    <th>Equity ƒê·∫ßu K·ª≥</th>
                    <th>Equity Hi·ªán T·∫°i</th>
                    <th>In</th>
                    <th>Out</th>
                    <th>PnL</th>
                    <th>%</th>
                </tr>
            </thead>
            <tbody>
                <tr><td colspan="9" style="padding: 30px; color: #999;">üëÜ Vui l√≤ng nh·∫≠p Link CSV ·ªü tr√™n...</td></tr>
            </tbody>
        </table>
    </div>

    <!-- B·∫¢NG X·∫æP H·∫†NG -->
    <div class="table-box">
        <h3>üèÜ B·∫£ng X·∫øp H·∫°ng PnL</h3>
        
        <!-- Th√™m select ƒë·ªÉ ch·ªçn nƒÉm, th√°ng v√† k·ª≥ -->
        <div class="period-filter">
            <label>üìÖ Ch·ªçn nƒÉm:</label>
            <select id="yearSelect" onchange="updateMonthsByYear()">
                <option value="all">T·∫•t c·∫£ nƒÉm</option>
            </select>
            
            <label style="margin-left: 15px;">üìÖ Ch·ªçn th√°ng:</label>
            <select id="monthSelect" onchange="updatePeriodsByMonth()">
                <option value="all">T·∫•t c·∫£ th√°ng</option>
            </select>
            
            <label style="margin-left: 15px;">üìä Ch·ªçn k·ª≥:</label>
            <select id="periodSelect" onchange="updateRankTable()">
                <option value="all">T·ªïng (T·∫•t c·∫£ k·ª≥)</option>
            </select>
        </div>
        
        <table id="rankTable">
            <thead>
                <tr>
                    <th>H·∫°ng</th>
                    <th>Account</th>
                    <th>Equity ƒê·∫ßu K·ª≥</th>
                    <th>Equity Hi·ªán T·∫°i</th>
                    <th>PnL</th>
                    <th>% L√£i</th>
                </tr>
            </thead>
            <tbody>
                <tr><td colspan="6" style="padding: 30px; color: #999;">ƒêang ch·ªù d·ªØ li·ªáu...</td></tr>
            </tbody>
        </table>
    </div>
</div>

<script>

const FIXED_CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vS6rHYACuA1J24SMrOu-cmdZCFWt094OjyfgD3IEh_cqAao_4r_pebRGgLy7wQpf93jWENp-C6noKuW/pub?output=csv";

localStorage.setItem('binanceCsvUrl', FIXED_CSV_URL);

let autoRefreshInterval;
let isAutoRefresh = true;
let loadCount = 0;
let lastDataHash = "";
let refreshIntervalSeconds = 300;
let CSV_URL = "";

// Bi·∫øn to√†n c·ª•c ƒë·ªÉ l∆∞u d·ªØ li·ªáu theo k·ª≥
let periodData = {};
let accountSummaryData = {};
let allPeriodsArray = []; // L∆∞u t·∫•t c·∫£ c√°c k·ª≥
let availableMonths = new Set(); // L∆∞u c√°c th√°ng c√≥ d·ªØ li·ªáu
let availableYears = new Set(); // L∆∞u c√°c nƒÉm c√≥ d·ªØ li·ªáu
let periodToMonthYear = {}; // Map period -> {month, year}

function init() {
    CSV_URL = localStorage.getItem('binanceCsvUrl') || "";
    document.getElementById('csvUrlInput').value = CSV_URL;
    
    if (CSV_URL) {
        document.getElementById('connectionStatus').innerHTML = '<span style="color: #28a745;">‚úÖ ƒê√£ k·∫øt n·ªëi</span>';
        document.getElementById('setupBanner').style.display = 'none';
        forceRefresh();
        startAutoRefresh();
    } else {
        showSetup();
    }
}

function showSetup() {
    document.getElementById('setupBanner').style.display = 'block';
}

function saveCsvUrl() {
    const url = document.getElementById('csvUrlInput').value.trim();
    
    if (!url) {
        showNotification('‚ö†Ô∏è Vui l√≤ng nh·∫≠p Link CSV!', 'error');
        return;
    }
    
    if (!url.includes('export?format=csv') && !url.includes('output=csv')) {
    showNotification('‚ö†Ô∏è Link ph·∫£i l√† CSV Google Sheets!', 'error');
    return;
    }
    
    CSV_URL = url;
    localStorage.setItem('binanceCsvUrl', url);
    
    document.getElementById('setupBanner').style.display = 'none';
    document.getElementById('connectionStatus').innerHTML = '<span style="color: #28a745;">‚úÖ ƒê√£ k·∫øt n·ªëi</span>';
    
    showNotification('‚úÖ ƒêang t·∫£i d·ªØ li·ªáu...');
    forceRefresh();
    startAutoRefresh();
}

function parseCSV(text) {
    const lines = text.replace(/\r/g, '').split('\n');
    const result = [];
    
    for (let line of lines) {
        const row = [];
        let cell = '';
        let inQuotes = false;
        
        for (let i = 0; i < line.length; i++) {
            const char = line[i];
            
            if (char === '"') {
                inQuotes = !inQuotes;
            } else if (char === ',' && !inQuotes) {
                row.push(cell.trim());
                cell = '';
            } else {
                cell += char;
            }
        }
        row.push(cell.trim());
        result.push(row);
    }
    
    return result;
}

function simpleHash(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        hash = ((hash << 5) - hash) + str.charCodeAt(i);
        hash = hash & hash;
    }
    return Math.abs(hash).toString(16).substring(0, 8);
}

function updateStatus(status, message) {
    const dot = document.getElementById('statusDot');
    const text = document.getElementById('statusText');
    dot.className = `status-dot ${status}`;
    text.textContent = message;
}

function showNotification(message, type = 'success') {
    const notif = document.getElementById('notification');
    notif.textContent = message;
    notif.className = `notification show ${type}`;
    setTimeout(() => notif.classList.remove('show'), 4000);
}

async function forceRefresh() {
    if (!CSV_URL) {
        showNotification('‚ö†Ô∏è Ch∆∞a c√≥ Link CSV!', 'error');
        showSetup();
        return;
    }
    
    const overlay = document.getElementById('loadingOverlay');
    overlay.classList.add('show');
    updateStatus('loading', 'ƒêang t·∫£i...');
    
    try {
        const timestamp = Date.now();
        const random = Math.random().toString(36).substring(7);
        
        let text = null;
        let method = "";
        
        // Method 1: Fetch tr·ª±c ti·∫øp
        try {
            const directUrl = CSV_URL.replace(/(&|\?)_=\d+/, '');
            const finalUrl = directUrl + (directUrl.includes('?') ? '&' : '?') + 'nocache=' + Date.now();
            const response = await fetch(finalUrl, {
                cache: 'no-store',
                mode: 'cors'
            });
            
            if (response.ok) {
                text = await response.text();
                method = "Direct Fetch";
            }
        } catch(e) {
        }
        
        // Method 2: CORS Proxy
        if (!text) {
            try {
                const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(CSV_URL)}`;
                const response = await fetch(proxyUrl);
                
                if (response.ok) {
                    text = await response.text();
                    method = "CORS Proxy";
                }
            } catch(e) {
            }
        }
        
        // Method 3: Alternative proxy
        if (!text) {
            try {
                const altProxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(CSV_URL)}`;
                const response = await fetch(altProxyUrl);
                
                if (response.ok) {
                    text = await response.text();
                    method = "AllOrigins Proxy";
                }
            } catch(e) {
            }
        }
        
        if (!text) {
            throw new Error('Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu. Vui l√≤ng ki·ªÉm tra:\n1. Link CSV c√≥ ƒë√∫ng kh√¥ng?\n2. Sheet ƒë√£ Publish ch∆∞a?\n3. Th·ª≠ b·∫•m "L√†m m·ªõi" l·∫°i');
        }
        
        const rows = parseCSV(text);
        
        const dataString = text;
        const newHash = simpleHash(dataString);
        
        if (newHash !== lastDataHash && lastDataHash !== "") {
            showNotification(`‚úÖ D·ªØ li·ªáu m·ªõi! (${method})`);
        }
        
        lastDataHash = newHash;
        
        const validRows = rows.slice(1).filter(r => r.length > 5 && r[1] && r[4]);
        
        if (validRows.length === 0) {
            throw new Error('Sheet kh√¥ng c√≥ d·ªØ li·ªáu h·ª£p l·ªá');
        }
        
        processDashboard(validRows);
        
        loadCount++;
        document.getElementById('loadCount').textContent = loadCount;
        
        const now = new Date();
        document.getElementById('lastUpdate').textContent = now.toLocaleTimeString('vi-VN') + ` (${method})`;
        
        updateStatus('success', '‚úÖ Th√†nh c√¥ng');
        
    } catch(e) {
        console.error("Error:", e);
        updateStatus('error', 'L·ªói');
        showNotification('‚ùå ' + e.message, 'error');
    } finally {
        overlay.classList.remove('show');
    }
}

function toggleAutoRefresh() {
    isAutoRefresh = !isAutoRefresh;
    const btn = document.getElementById('autoRefreshBtn');
    
    if (isAutoRefresh) {
        btn.textContent = '‚è∏Ô∏è T·∫°m d·ª´ng';
        btn.className = 'btn btn-secondary';
        startAutoRefresh();
        showNotification('‚ñ∂Ô∏è ƒê√£ b·∫≠t t·ª± ƒë·ªông');
    } else {
        btn.textContent = '‚ñ∂Ô∏è B·∫≠t t·ª± ƒë·ªông';
        btn.className = 'btn btn-primary';
        stopAutoRefresh();
        showNotification('‚è∏Ô∏è ƒê√£ t·∫°m d·ª´ng');
    }
}

function startAutoRefresh() {
    if (autoRefreshInterval) clearInterval(autoRefreshInterval);
    autoRefreshInterval = setInterval(forceRefresh, refreshIntervalSeconds * 1000);
}

function stopAutoRefresh() {
    if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
        autoRefreshInterval = null;
    }
}

function extractMonthAndYearFromRow(row) {
    // ƒê·ªçc tr·ª±c ti·∫øp t·ª´ c·ªôt "Th√°ng" (index 10) v√† "NƒÉm" (index 11)
    let month = null;
    let year = null;
    
    // C·ªôt Th√°ng
    if (row[10]) {
        const monthStr = String(row[10]).trim();
        if (monthStr) {
            month = parseInt(monthStr);
            if (isNaN(month) || month < 1 || month > 12) {
                month = null;
            }
        }
    }
    
    // C·ªôt NƒÉm
    if (row[11]) {
        const yearStr = String(row[11]).trim();
        if (yearStr) {
            year = parseInt(yearStr);
            if (isNaN(year) || year < 2000 || year > 2100) {
                year = null;
            }
        }
    }
    
    // Backup: N·∫øu kh√¥ng c√≥ gi√° tr·ªã, th·ª≠ extract t·ª´ c·ªôt "K·ª≥"
    if (!month || !year) {
        const period = String(row[2] || "").trim();
        const { months, years } = extractMonthsAndYearsFromPeriod(period);
        
        if (!month && months.length > 0) {
            month = months[0]; // L·∫•y th√°ng ƒë·∫ßu ti√™n
        }
        if (!year && years.length > 0) {
            year = years[0]; // L·∫•y nƒÉm ƒë·∫ßu ti√™n
        }
    }
    
    return { month, year };
}

function extractMonthsAndYearsFromPeriod(period) {
    // Tr√≠ch xu·∫•t th√°ng v√† nƒÉm t·ª´ c·ªôt "K·ª≥" (backup method)
    const months = [];
    const years = [];
    
    const periodStr = String(period);
    
    // Pattern 1: DD/MM/YYYY-DD/MM/YYYY (c√≥ nƒÉm)
    const dateWithYearMatches = periodStr.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})/g);
    if (dateWithYearMatches) {
        for (let dateStr of dateWithYearMatches) {
            const parts = dateStr.split('/');
            if (parts.length >= 3) {
                const monthInDate = parseInt(parts[1]);
                const yearInDate = parseInt(parts[2]);
                
                if (monthInDate >= 1 && monthInDate <= 12 && !months.includes(monthInDate)) {
                    months.push(monthInDate);
                }
                if (yearInDate >= 2000 && yearInDate <= 2100 && !years.includes(yearInDate)) {
                    years.push(yearInDate);
                }
            }
        }
    }
    
    // Pattern 2: DD/MM-DD/MM (kh√¥ng c√≥ nƒÉm) - v√≠ d·ª• "1/12-14/12" ho·∫∑c "15/12-31/12"
    if (months.length === 0) {
        const dateWithoutYearMatches = periodStr.match(/(\d{1,2})\/(\d{1,2})/g);
        if (dateWithoutYearMatches) {
            for (let dateStr of dateWithoutYearMatches) {
                const parts = dateStr.split('/');
                if (parts.length >= 2) {
                    const monthInDate = parseInt(parts[1]);
                    if (monthInDate >= 1 && monthInDate <= 12 && !months.includes(monthInDate)) {
                        months.push(monthInDate);
                    }
                }
            }
        }
    }
    
    return { months, years };
}

function checkPeriodMatchesFilter(period, month, year, rowMonth, rowYear) {
    // So s√°nh tr·ª±c ti·∫øp v·ªõi th√°ng/nƒÉm t·ª´ c·ªôt d·ªØ li·ªáu
    
    // N·∫øu ch·ªçn "T·∫•t c·∫£"
    if (month === null && year === null) return true;
    
    // N·∫øu ch·ªâ ch·ªçn nƒÉm
    if (month === null && year !== null) {
        return rowYear === year;
    }
    
    // N·∫øu ch·ªâ ch·ªçn th√°ng
    if (month !== null && year === null) {
        return rowMonth === month;
    }
    
    // N·∫øu ch·ªçn c·∫£ th√°ng v√† nƒÉm
    return rowMonth === month && rowYear === year;
}

function updateMonthsByYear() {
    const selectedYear = document.getElementById('yearSelect').value;
    const monthSelect = document.getElementById('monthSelect');
    
    // L∆∞u gi√° tr·ªã hi·ªán t·∫°i
    const currentValue = monthSelect.value;
    
    // Reset month select
    monthSelect.innerHTML = '<option value="all">T·∫•t c·∫£ th√°ng</option>';
    
    // L·ªçc c√°c k·ª≥ theo nƒÉm ƒë√£ ch·ªçn
    let monthsInYear = new Set();
    
    if (selectedYear === 'all') {
        // Hi·ªÉn th·ªã t·∫•t c·∫£ th√°ng c√≥ trong d·ªØ li·ªáu
        monthsInYear = availableMonths;
    } else {
        const year = parseInt(selectedYear);
        
        // L·∫•y c√°c th√°ng t·ª´ c√°c period c√≥ nƒÉm t∆∞∆°ng ·ª©ng
        allPeriodsArray.forEach(period => {
            const periodInfo = periodToMonthYear[period];
            if (periodInfo && periodInfo.year === year && periodInfo.month) {
                monthsInYear.add(periodInfo.month);
            }
        });
    }
    
    // S·∫Øp x·∫øp v√† th√™m v√†o select
    const monthsArray = Array.from(monthsInYear).sort((a, b) => a - b);

    
    monthsArray.forEach(month => {
        const option = document.createElement('option');
        option.value = month.toString();
        option.textContent = `Th√°ng ${month}`;
        monthSelect.appendChild(option);
    });
    
    // Kh√¥i ph·ª•c gi√° tr·ªã ƒë√£ ch·ªçn n·∫øu c√≤n t·ªìn t·∫°i
    if (Array.from(monthSelect.options).some(opt => opt.value === currentValue)) {
        monthSelect.value = currentValue;
    }
    
    // C·∫≠p nh·∫≠t danh s√°ch k·ª≥
    updatePeriodsByMonth();
}

function updatePeriodsByMonth() {
    const selectedYear = document.getElementById('yearSelect').value;
    const selectedMonth = document.getElementById('monthSelect').value;
    const periodSelect = document.getElementById('periodSelect');
    
    // L∆∞u gi√° tr·ªã hi·ªán t·∫°i
    const currentValue = periodSelect.value;
    
    // Reset period select
    periodSelect.innerHTML = '<option value="all">T·ªïng (T·∫•t c·∫£ k·ª≥)</option>';
    
    const year = selectedYear === 'all' ? null : parseInt(selectedYear);
    const month = selectedMonth === 'all' ? null : parseInt(selectedMonth);
    
    // Filter periods theo year v√† month
    const filteredPeriods = allPeriodsArray.filter(period => {
        const periodInfo = periodToMonthYear[period];
        if (!periodInfo) return false;
        
        // N·∫øu ch·ªçn "T·∫•t c·∫£"
        if (year === null && month === null) return true;
        
        // N·∫øu ch·ªâ ch·ªçn nƒÉm
        if (year !== null && month === null) {
            return periodInfo.year === year;
        }
        
        // N·∫øu ch·ªâ ch·ªçn th√°ng (kh√¥ng ch·ªçn nƒÉm)
        if (year === null && month !== null) {
            return periodInfo.month === month;
        }
        
        // N·∫øu ch·ªçn c·∫£ nƒÉm v√† th√°ng
        return periodInfo.year === year && periodInfo.month === month;
    });

    
    // Th√™m c√°c k·ª≥ ƒë√£ filter v√†o select
    filteredPeriods.forEach(period => {
        const option = document.createElement('option');
        option.value = period;
        option.textContent = period;
        periodSelect.appendChild(option);
    });
    
    // Kh√¥i ph·ª•c gi√° tr·ªã ƒë√£ ch·ªçn n·∫øu c√≤n t·ªìn t·∫°i
    if (Array.from(periodSelect.options).some(opt => opt.value === currentValue)) {
        periodSelect.value = currentValue;
    }
    
    // C·∫≠p nh·∫≠t b·∫£ng x·∫øp h·∫°ng
    updateRankTable();
}

function processDashboard(data) {
    // Reset d·ªØ li·ªáu
    periodData = {};
    accountSummaryData = {};
    allPeriodsArray = [];
    availableMonths = new Set();
    availableYears = new Set();
    periodToMonthYear = {};
    
    // Group data by account v√† period
    let accountData = {};
    let allPeriods = new Set();
    
    // Pass 1: ƒê·ªçc t·∫•t c·∫£ d·ªØ li·ªáu v√† build periodToMonthYear mapping
    data.forEach(r => {
        if (!r[1]) return;
        
        let period = String(r[2]).trim();
        if (!period) return;
        
        allPeriods.add(period);
        
        // ƒê·ªçc th√°ng v√† nƒÉm t·ª´ c·ªôt d·ªØ li·ªáu
        const { month, year } = extractMonthAndYearFromRow(r);
        
        // N·∫øu ch∆∞a c√≥ mapping cho period n√†y, ho·∫∑c mapping hi·ªán t·∫°i ch∆∞a ƒë·∫ßy ƒë·ªß
        if (!periodToMonthYear[period] || 
            (!periodToMonthYear[period].month && month) || 
            (!periodToMonthYear[period].year && year)) {
            
            periodToMonthYear[period] = {
                month: month || periodToMonthYear[period]?.month || null,
                year: year || periodToMonthYear[period]?.year || null
            };
        }
    });
    
    // Pass 2: V·ªõi c√°c period ch∆∞a c√≥ ƒë·∫ßy ƒë·ªß month/year, th·ª≠ extract t·ª´ t√™n period
    allPeriods.forEach(period => {
        if (!periodToMonthYear[period] || !periodToMonthYear[period].month || !periodToMonthYear[period].year) {
            const { months, years } = extractMonthsAndYearsFromPeriod(period);
            
            if (!periodToMonthYear[period]) {
                periodToMonthYear[period] = { month: null, year: null };
            }
            
            if (!periodToMonthYear[period].month && months.length > 0) {
                periodToMonthYear[period].month = months[0];
            }
            
            if (!periodToMonthYear[period].year && years.length > 0) {
                periodToMonthYear[period].year = years[0];
            }
        }
    });
    
    // Pass 2.5: V·ªõi c√°c period c√≥ th√°ng nh∆∞ng kh√¥ng c√≥ nƒÉm, 
    // th·ª≠ t√¨m nƒÉm t·ª´ c√°c period kh√°c c√πng th√°ng
    allPeriods.forEach(period => {
        const periodInfo = periodToMonthYear[period];
        
        if (periodInfo && periodInfo.month && !periodInfo.year) {
            // T√¨m period kh√°c c√πng th√°ng c√≥ nƒÉm
            for (let otherPeriod of allPeriods) {
                const otherInfo = periodToMonthYear[otherPeriod];
                if (otherInfo && otherInfo.month === periodInfo.month && otherInfo.year) {
                    periodInfo.year = otherInfo.year;
                    break;
                }
            }
        }
        
        // Thu th·∫≠p c√°c th√°ng v√† nƒÉm c√≥ trong d·ªØ li·ªáu
        if (periodInfo.month) {
            availableMonths.add(periodInfo.month);
        }
        if (periodInfo.year) {
            availableYears.add(periodInfo.year);
        }
    });

    
    // Pass 3: X·ª≠ l√Ω d·ªØ li·ªáu ch√≠nh
    data.forEach(r => {
        if (!r[1]) return;
        
        let stt = parseInt(r[0]) || 0;
        let account = String(r[1]).trim();
        let period = String(r[2]).trim();
        let equityStart = parseFloat(String(r[4]).replace(/"/g,"").replace(",", ".")) || 0;
        let equityNow = parseFloat(String(r[5]).replace(/"/g,"").replace(",", ".")) || 0;
        let inAmount = parseFloat(String(r[6]).replace(/"/g,"").replace(",", ".")) || 0;
        let outAmount = parseFloat(String(r[7]).replace(/"/g,"").replace(",", ".")) || 0;
        let pnl = parseFloat(String(r[8]).replace(/"/g,"").replace(",", ".")) || 0;
        let percent = String(r[9] || "").trim();

        // L·∫•y month/year t·ª´ mapping ƒë√£ build
        const periodInfo = periodToMonthYear[period] || { month: null, year: null };
        const month = periodInfo.month;
        const year = periodInfo.year;

        if (!accountData[account]) {
            accountData[account] = [];
        }
        
        accountData[account].push({
            stt,
            account,
            period,
            month,
            year,
            equityStart,
            equityNow,
            inAmount,
            outAmount,
            pnl,
            percent
        });
        
        // L∆∞u d·ªØ li·ªáu theo k·ª≥
        if (!periodData[period]) {
            periodData[period] = {};
        }
        if (!periodData[period][account]) {
            periodData[period][account] = {
                equityStart: 0,
                equityNow: 0,
                pnl: 0,
                percent: percent,
                month: month,
                year: year
            };
        }
        
        periodData[period][account] = {
            equityStart: equityStart,
            equityNow: equityNow,
            pnl: pnl,
            percent: percent,
            month: month,
            year: year
        };
    });
    
    // L∆∞u t·∫•t c·∫£ c√°c k·ª≥ ƒë√£ s·∫Øp x·∫øp
    allPeriodsArray = Array.from(allPeriods).sort();
    
    
    // C·∫≠p nh·∫≠t select nƒÉm, th√°ng v√† k·ª≥
    updateYearSelect();
    updateMonthsByYear();
    
    // T√≠nh to√°n t·ªïng h·ª£p
    let sumEquityStart = 0;
    let sumEquityNow = 0;
    let sumPnL = 0;
    let allRows = [];
    
    Object.keys(accountData).forEach(account => {
        let periods = accountData[account];
        periods.sort((a, b) => a.stt - b.stt);
        
        let firstPeriod = periods[0];
        let lastPeriod = periods[periods.length - 1];
        
        let totalPnL = periods.reduce((sum, p) => sum + p.pnl, 0);
        
        accountSummaryData[account] = {
            equityStart: firstPeriod.equityStart,
            equityNow: lastPeriod.equityNow,
            totalPnL: totalPnL,
            count: periods.length
        };
        
        sumEquityStart += firstPeriod.equityStart;
        sumEquityNow += lastPeriod.equityNow;
        sumPnL += totalPnL;
        
        allRows = allRows.concat(periods);
    });
    
    const avgPercent = sumEquityStart > 0 ? ((sumPnL / sumEquityStart) * 100).toFixed(2) : 0;

    document.getElementById("sumEquityStart").textContent = sumEquityStart.toLocaleString("vi-VN", {minimumFractionDigits: 2});
    document.getElementById("sumEquityNow").textContent = sumEquityNow.toLocaleString("vi-VN", {minimumFractionDigits: 2});
    
    const pnlElement = document.getElementById("sumPnL");
    pnlElement.textContent = sumPnL.toLocaleString("vi-VN", {minimumFractionDigits: 2});
    pnlElement.className = sumPnL >= 0 ? "value green" : "value red";

    const avgElement = document.getElementById("avgPercent");
    avgElement.textContent = avgPercent + "%";
    avgElement.className = avgPercent >= 0 ? "value green" : "value red";

    drawDetailTable(allRows);
    updateRankTable();
}

function updateYearSelect() {
    const yearSelect = document.getElementById('yearSelect');
    
    // L∆∞u gi√° tr·ªã hi·ªán t·∫°i
    const currentValue = yearSelect.value;
    
    // Reset year select
    yearSelect.innerHTML = '<option value="all">T·∫•t c·∫£ nƒÉm</option>';
    
    // Chuy·ªÉn Set th√†nh Array v√† s·∫Øp x·∫øp (nƒÉm m·ªõi nh·∫•t tr∆∞·ªõc)
    let yearsArray = Array.from(availableYears).sort((a, b) => b - a);
    
    
    // Th√™m c√°c nƒÉm v√†o select
    yearsArray.forEach(year => {
        const option = document.createElement('option');
        option.value = year.toString();
        option.textContent = `NƒÉm ${year}`;
        yearSelect.appendChild(option);
    });
    
    // Kh√¥i ph·ª•c gi√° tr·ªã ƒë√£ ch·ªçn n·∫øu c√≤n t·ªìn t·∫°i
    if (Array.from(yearSelect.options).some(opt => opt.value === currentValue)) {
        yearSelect.value = currentValue;
    }
}

function updateRankTable() {
    const selectedYear = document.getElementById('yearSelect').value;
    const selectedMonth = document.getElementById('monthSelect').value;
    const selectedPeriod = document.getElementById('periodSelect').value;
    
    const rankTableBox = document.querySelector('#rankTable').closest('.table-box');
    
    if (selectedPeriod === 'all') {
        // N·∫øu ch·ªçn "T·ªïng" - t√≠nh t·ªïng theo filter nƒÉm/th√°ng
        const year = selectedYear === 'all' ? null : parseInt(selectedYear);
        const month = selectedMonth === 'all' ? null : parseInt(selectedMonth);
        
        // Filter periods theo year v√† month
        const filteredPeriods = allPeriodsArray.filter(period => {
            const periodInfo = periodToMonthYear[period];
            if (!periodInfo) return false;
            
            // N·∫øu ch·ªçn "T·∫•t c·∫£"
            if (year === null && month === null) return true;
            
            // N·∫øu ch·ªâ ch·ªçn nƒÉm
            if (year !== null && month === null) {
                return periodInfo.year === year;
            }
            
            // N·∫øu ch·ªâ ch·ªçn th√°ng
            if (year === null && month !== null) {
                return periodInfo.month === month;
            }
            
            // N·∫øu ch·ªçn c·∫£ nƒÉm v√† th√°ng
            return periodInfo.year === year && periodInfo.month === month;
        });
        
        if (filteredPeriods.length === 0) {
            // Kh√¥ng c√≥ d·ªØ li·ªáu - ·∫©n b·∫£ng
            rankTableBox.style.display = 'none';
            return;
        }
        
        // T√≠nh t·ªïng t·ª´ c√°c periods ƒë√£ filter
        const summaryData = calculateSummaryFromPeriods(filteredPeriods);
        
        if (Object.keys(summaryData).length === 0) {
            rankTableBox.style.display = 'none';
            return;
        }
        
        rankTableBox.style.display = 'block';
        drawRankTable(summaryData, 'T·ªïng');
    } else {
        // Hi·ªÉn th·ªã theo k·ª≥ c·ª• th·ªÉ
        if (periodData[selectedPeriod]) {
            rankTableBox.style.display = 'block';
            drawRankTable(periodData[selectedPeriod], selectedPeriod);
        } else {
            // Kh√¥ng c√≥ d·ªØ li·ªáu - ·∫©n b·∫£ng
            rankTableBox.style.display = 'none';
        }
    }
}

function calculateSummaryFromPeriods(periods) {
    // T√≠nh to√°n t·ªïng h·ª£p t·ª´ c√°c periods ƒë∆∞·ª£c ch·ªçn
    const summary = {};
    
    periods.forEach(period => {
        if (periodData[period]) {
            Object.keys(periodData[period]).forEach(account => {
                if (!summary[account]) {
                    summary[account] = {
                        equityStart: 0,
                        equityNow: 0,
                        totalPnL: 0
                    };
                }
                
                const data = periodData[period][account];
                // L·∫•y equity ƒë·∫ßu t·ª´ period ƒë·∫ßu ti√™n
                if (summary[account].equityStart === 0) {
                    summary[account].equityStart = data.equityStart;
                }
                // C·∫≠p nh·∫≠t equity cu·ªëi t·ª´ period m·ªõi nh·∫•t
                summary[account].equityNow = data.equityNow;
                // C·ªông d·ªìn PnL
                summary[account].totalPnL += data.pnl;
            });
        }
    });
    
    return summary;
}

function drawDetailTable(rows) {
    rows.sort((a, b) => a.stt - b.stt);
    
    let html = "";
    rows.forEach((row) => {
        let pnlColor = row.pnl >= 0 ? "green" : "red";
        
        html += `
            <tr>
                <td><strong>${row.stt}</strong></td>
                <td><strong>${row.account}</strong></td>
                <td><span class="period-badge">${row.period}</span></td>
                <td>${row.equityStart.toLocaleString("vi-VN", {minimumFractionDigits: 2})}</td>
                <td>${row.equityNow.toLocaleString("vi-VN", {minimumFractionDigits: 2})}</td>
                <td>${row.inAmount.toLocaleString("vi-VN", {minimumFractionDigits: 2})}</td>
                <td>${row.outAmount.toLocaleString("vi-VN", {minimumFractionDigits: 2})}</td>
                <td class="${pnlColor}"><strong>${row.pnl.toLocaleString("vi-VN", {minimumFractionDigits: 2})}</strong></td>
                <td class="${pnlColor}"><strong>${row.percent}</strong></td>
            </tr>
        `;
    });

    document.querySelector("#detailTable tbody").innerHTML = html;
}

function drawRankTable(dataToRank, periodLabel) {
    let accounts;
    
    // Ki·ªÉm tra n·∫øu kh√¥ng c√≥ d·ªØ li·ªáu
    if (!dataToRank || Object.keys(dataToRank).length === 0) {
        document.querySelector("#rankTable tbody").innerHTML = 
            '<tr><td colspan="6" style="padding: 30px; color: #999;">‚ö†Ô∏è Kh√¥ng c√≥ d·ªØ li·ªáu cho l·ª±a ch·ªçn n√†y</td></tr>';
        return;
    }
    
    if (periodLabel === 'T·ªïng') {
        // X·∫øp h·∫°ng theo t·ªïng PnL
        accounts = Object.keys(dataToRank).map(acc => ({
            account: acc,
            equityStart: dataToRank[acc].equityStart,
            equityNow: dataToRank[acc].equityNow,
            pnl: dataToRank[acc].totalPnL,
            profitPercent: dataToRank[acc].equityStart > 0 
                ? ((dataToRank[acc].totalPnL / dataToRank[acc].equityStart) * 100).toFixed(2)
                : 0
        }));
    } else {
        // X·∫øp h·∫°ng theo k·ª≥ c·ª• th·ªÉ
        accounts = Object.keys(dataToRank).map(acc => ({
            account: acc,
            equityStart: dataToRank[acc].equityStart,
            equityNow: dataToRank[acc].equityNow,
            pnl: dataToRank[acc].pnl,
            profitPercent: dataToRank[acc].equityStart > 0 
                ? ((dataToRank[acc].pnl / dataToRank[acc].equityStart) * 100).toFixed(2)
                : dataToRank[acc].percent.replace('%', '') || 0
        }));
    }

    accounts.sort((a, b) => b.pnl - a.pnl);

    let html = "";
    accounts.forEach((item, i) => {
        let pnlColor = item.pnl >= 0 ? "green" : "red";
        let rankIcon = i === 0 ? "ü•á" : i === 1 ? "ü•à" : i === 2 ? "ü•â" : (i + 1);
        let rowClass = i < 3 ? `rank-${i+1}` : '';
        
        html += `
            <tr class="${rowClass}">
                <td><strong>${rankIcon}</strong></td>
                <td><strong>${item.account}</strong></td>
                <td>${item.equityStart.toLocaleString("vi-VN", {minimumFractionDigits: 2})}</td>
                <td>${item.equityNow.toLocaleString("vi-VN", {minimumFractionDigits: 2})}</td>
                <td class="${pnlColor}"><strong>${item.pnl.toLocaleString("vi-VN", {minimumFractionDigits: 2})}</strong></td>
                <td class="${pnlColor}"><strong>${item.profitPercent}%</strong></td>
            </tr>
        `;
    });

    document.querySelector("#rankTable tbody").innerHTML = html;
}

init();

</script>

</body>
</html>